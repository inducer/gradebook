#! /usr/bin/env python
#

from optparse import OptionParser

parser = OptionParser(usage="usage: %prog [options] COURSE_ID ASSIGNMENT_KIND ASSIGNMENT_NUMBER ASSIGNMENT_PREFIX")
parser.add_option("-s", "--start-terminal",
                  action="store_true", default=True,
                  help="automatically start a terminal in the grading directory")

(options, args) = parser.parse_args()

if len(args) < 4:
    parser.print_usage()
    import sys
    sys.exit(1)

course_id, kind, number, name = args

# {{{ boilerplate

from camelot.core.orm import Session
import os, sys
sys.path.append(os.environ["GRADEBOOK_ROOT"])
import main

from camelot.core.conf import settings
settings.setup_model()

from gradebook.model import get_user

# }}}

session = Session()

from gradebook.model import (Student, Assignment,
        AssignmentStateChange as ASC)

assmt = (session.query(Assignment)
        .filter(Assignment.course_id == course_id)
        .filter(Assignment.kind == kind)
        .filter(Assignment.number == number)).one()

print "---------------------------------------------"
print unicode(assmt)
print "---------------------------------------------"

import os

cwd = os.path.join(os.getcwd(), name)

from subprocess import call

for student in session.query(Student):
    user_name = student.user_name

    state_changes = list(session.query(ASC)
            .filter(ASC.assignment == assmt)
            .filter(ASC.student == student)
            .order_by(ASC.timestamp))

    needs_grading = None
    for sc in state_changes:
        if sc.new_state == "retrieved":
            needs_grading = True

    if not needs_grading:
        print "%-10s: [-] not available as of %s" % (user_name, sc.timestamp)
        continue

    for sc in state_changes:
        if sc.new_state == "graded":
            print "%-10s: [X] graded (%s points) as of %s" % (
                    user_name, sc.points, sc.timestamp)
            needs_grading = False

    if not needs_grading:
        continue

    already_marked = False
    for sc in state_changes:
        if sc.new_state == "grading-started" and get_user() != sc.user:
            print "%-10s: [?] %s has started grading this assignment at" % (
                    user_name, sc.user, sc.timestamp)
            needs_grading = False
        if sc.new_state == "grading-started" and get_user() == sc.user:
            already_marked = True
            print "%-10s: [?] you started grading this assignment at %s" % (
                    user_name, sc.timestamp)

    if not needs_grading:
        continue

    if not already_marked:
        print "%-10s: [O] marking as started" % user_name

        session.add(ASC(
            student=student, assignment=assmt,
            new_state=u"grading-started"))
        session.flush()

    print "%-10s: grading..." % user_name

    while True:
        hw_dir = os.path.join(cwd, user_name)
        report_file = os.path.join(hw_dir, "grade.txt")

        if not os.path.exists(report_file):
            with open(os.path.join(cwd, "template.txt"), "rb") as inf:
                with open(report_file, "wb") as outf:
                    outf.write(inf.read())

        if options.start_terminal:
            call(["x-terminal-emulator"], cwd=hw_dir)

        import os
        if "EDITOR" in os.environ:
            editor = os.environ["EDITOR"].split()
        else:
            editor = ["vim"]

        call(editor+[report_file])

        import codecs
        with codecs.open(report_file, "r", "utf-8") as inf:
            report_lines = [l.rstrip() for l in inf.readlines()]

        import re
        total_re = re.compile("^TOTAL(.*)::.*$")
        subtotal_re = re.compile("^SUBTOTAL(.*)::.*$")
        points_re = re.compile("^.*::\s*([-0-9.]+)\s*$")

        running_total = 0
        running_subtotal = 0

        for i, l in enumerate(report_lines):
            m = total_re.match(l)
            if m is not None:
                report_lines[i] = "TOTAL%s:: %s" % (m.group(1), running_total)
                continue

            m = subtotal_re.match(l)
            if m is not None:
                report_lines[i] = "SUBTOTAL%s:: %s" % (m.group(1), running_subtotal)
                running_subtotal = 0
                continue

            m = points_re.match(l)
            if m is not None:
                pts = float(m.group(1))
                running_total += pts
                running_subtotal += pts

        report = u"\n".join(report_lines)

        with codecs.open(report_file, "w", "utf-8") as outf:
            outf.write(report)

        print 75*"-"
        print "Grade report for '%s'" % user_name
        print 75*"-"
        print report
        print 75*"-"
        print "Total: %s/%s points" % (running_total, assmt.possible_points)

        answer = raw_input("accept [n]?")
        if answer == "y":
            session.add(ASC(
                student=student, assignment=assmt,
                new_state=u"graded", points=running_total,
                report="<pre>%s</pre>" % report))
            session.flush()
            break
